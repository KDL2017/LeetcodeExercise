//2.两数相加 难度：中等 提示：双指针
    //我的解题思路：
    //  不进位直接加完存储在当前位置
    //  进位需要用到下一位指针：下一位加和÷10，当前位和余10
    //  需要判断是否已经到最后一位
    //  可以直接存储到其中一个数组，不用再分配新的空间(不好操作？)

    /*ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {//试试递归，还未成功
        ListNode* left1 = l1;
        ListNode* right1 = l1->next;
        ListNode* left2 = l2;
        ListNode* right2 = l2->next;
        while (right1 != nullptr || right2 != nullptr)
        {
            if (right1 != nullptr && right2 != nullptr)
            {
                if (left1->val + left2->val < 10)
                    left1->val = left1->val + left2->val;
                else
                {
                    right1->val++;
                    left1->val = (left1->val + left2->val) % 10;
                }
                left1 = left1->next;
                right1 = right1->next;
                left2 = left2->next;
                right2 = right2->next;
            }
            if (right1 == nullptr)
            {

            }
            
        }
    }*/

    //成功通过，2024/8/27
    //思路：将两链表处理成等长再计算
    //运行时间和内存消耗表现不佳
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* l1_head = l1;
        while (l1 != nullptr && l2 != nullptr)
        {
            if (l1->val + l2->val < 10) //不进位
                l1->val = l1->val + l2->val;
            else if (l1->val + l2->val >= 10 && l1->next != nullptr) //普通进位
            {
                (l1->next->val)++;
                l1->val = (l1->val + l2->val) % 10;
            }
            else if (l1->val + l2->val >= 10 && l1->next == nullptr) //进位时下一位存储空间为nullptr
            {
                l1->next = new ListNode(1);
                l1->val = (l1->val + l2->val) % 10;
            }
            if (l2->next == nullptr && l1->next != nullptr) //补长，下同
                l2->next = new ListNode(0);
            else if (l2->next != nullptr && l1->next == nullptr)
                l1->next = new ListNode(0);
            l1 = l1->next;
            l2 = l2->next;
        }
        return l1_head;
    }

    //官方题解
    //作者：力扣官方题解
    //链接：（https ://leetcode.cn/problems/add-two-numbers/solutions/435246/liang-shu-xiang-jia-by-leetcode-solution/）
    //来源：力扣（LeetCode）
    //相较于我自己的方法，速度明显提升，消耗内存变大
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr, * tail = nullptr; //开辟新空间存储
        int carry = 0; //进位值
        while (l1 || l2) {
            int n1 = l1 ? l1->val : 0; //提取l1节点携带值，若l1为空指针则取0
            int n2 = l2 ? l2->val : 0; //同上
            int sum = n1 + n2 + carry;
            if (!head) { //初始链表头为空
                head = tail = new ListNode(sum % 10);
            }
            else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        if (carry > 0) { //最后一位有进位值，需要多出一位存储
            tail->next = new ListNode(carry);
        }
        return head;
    }
