    //10.正则表达式匹配 难度：困难 提示：递归，动态规划
    //我的解题思路：
    //  每匹配掉一个字符，问题规模就会变小一点
    //  当待匹配字符串为空时，说明匹配成功，返回true
    //  由于'*'的存在，字符规律p需要多看一位，应该可以用双指针来解决
    //  匹配模式有如下几种：(字母)--(字母)，(字母)--(.)，(字母)--(字母*)，(字母)--(.*)
    
    //第一次提交错误：s="ab",p="abc" 答案应为false，我得到的是true 显然是p中最后一位'c'导致的，如果为'c*'则为true
    //第二次提交错误：s="aaa",p="a*a" 答案应为true，我得到的是false 问题在于a*把aaa匹配完了，p的最后一个a无法匹配导致false
    //屎山最后还是没能通过，2024/8/29
    //内心OS：想法是到位了，代码能力太差了
    /*bool isMatch(string s, string p) {
        if (s.empty() && p.size() > 2 && p[1] == '*')
        {
            return isMatch(s, p.substr(2));
        }
        else if (s.empty() && p.size() == 2 && p[1] == '*')
            return true;
        //else if (s.size() == 1 && p.size() == 1 && (s.front() == p.front() || p.front() == '.'))
        else if(s.empty() && p.empty())
            return true;
        else if (!s.empty() && p.empty())
            return false;
        else if (s.empty() && p.size() > 2 && p[1] != '*')
            return false;
        else if (s.front() != p.front() && p.front() != '.' && p.size() == 1)
            return false;
        else if (s.empty() && p.size() == 1)
            return false;
        if (p.front() == '.' && ((p.size() > 1 && p[1] != '*') || p.size() == 1))
        {
            return isMatch(s.substr(1), p.substr(1));
        }
        else if (p.front() == '.' && p.size() > 1 && p[1] == '*')
        {
            return isMatch(s.substr(1), p) || isMatch(s, p.substr(2));
        }
        else if (s.front() == p.front() && p.size() > 1 && p[1] == '*')
        {
            return isMatch(s.substr(1), p) || isMatch(s, p.substr(2));
        }
        else if (s.front() != p.front() && p.size() > 1 && p[1] == '*')
        {
            return isMatch(s, p.substr(2));
        }
        else
        {
            return isMatch(s.substr(1), p.substr(1));
        }
     }*/

    //再次尝试，2024/8/30
    //还是失败
    /*bool isMatch(string s, string p) {
        int s_len = s.size();
        int p_len = p.size();

        auto match = [&](int i, int j) {
            if (i == 0)
                return false;
            if (p[j - 1] == '.')
                return true;
            return s[i - 1] == p[i - 1];
        };

        vector<vector<bool>> flag(s_len + 1, vector<bool>(p_len + 1));
        flag[0][0] = true; // 当s和p同时为空，匹配成功
        for (int i = 0; i <= s_len; ++i)
        {
            for (int j = 1; j <= p_len; ++i)
            {
                if (p[j - 1] == '*')
                {
                    if (match(i, j - 1))
                        flag[i][j] = flag[i - 1][j] || flag[i][j - 2];
                    else
                        flag[i][j] = flag[i][j - 2];
                }
                else
                {
                    if (match(i, j))
                        flag[i][j] = flag[i - 1][j - 1]; // 超出范围了
                    else
                        flag[i][j] = false;
                }
            }
        }
        return flag[s_len][p_len];
    }*/

    //官方题解
    //作者：力扣官方题解
    //链接：https ://leetcode.cn/problems/regular-expression-matching/solutions/295977/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/
    //最重要的是写出正确的状态转移方程，另外每个状态最好用矩阵来保存
    //吸取的教训：要是每一次递归都用函数返回，不仅代码难写，而且资源消耗大
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        auto matches = [&](int i, int j) { //lambda 表达式——匿名函数,用来判断单个字符是否匹配
            if (i == 0) // 由于采用的是i,j对应s[i - 1],p[j - 1]，所以i为0时直接返回false
                return false;
            if (p[j - 1] == '.')
                return true;
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true; // 当s和p同时为空，匹配成功
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    // 对应  p[j] == '*'
                    // matches(i, j - 1)无论能否匹配 
                    // f[i][j] |= f[i][j - 2]都会存在 
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        //  匹配 使用组合
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    // 对应  p[j] != '*'
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
