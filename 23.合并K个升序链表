    //23.合并K个升序链表 难度：困难
    //我的解题思路：
    //  转化为合并两个升序链表，即每次只合并两个链表

    //成功通过，2024/9/9
    //一次通过，但显然时间复杂度比较高
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int n = lists.size();
        if (n == 0)
            return nullptr;
        ListNode* ans = nullptr;
        for (int i = 0; i < n; ++i)
            ans = mergeTwoLists(ans, lists[i]);
        return ans;
    }

    //我可以想到的改进：
    //  把链表两两分成一组，每次按组合并
    //  例如初始有8组，则8->4->2->1这样合并
    //成功通过，2024/9/9
    //时间消耗明显减少
    ListNode* merge(vector <ListNode*>& lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1; // 位运算，右移一位，起到除以2的效果
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head;
        if (l1 == nullptr)
            return l2;
        else if (l2 == nullptr)
            return l1;
        else
        {
            if (l1->val <= l2->val)
            {
                head = l1;
                l1 = l1->next;
            }
            else
            {
                head = l2;
                l2 = l2->next;
            }
        }
        ListNode* tail = head;
        while (l1 != nullptr || l2 != nullptr)
        {
            if  (l1 == nullptr) {
                tail->next = l2;
                return head;
            }
            else if (l2 == nullptr) {
                tail->next = l1;
                return head;
            }
            else {
                if (l1->val <= l2->val) {
                    tail->next = l1;
                    tail = tail->next;
                    l1 = l1->next;
                }
                else {
                    tail->next = l2;
                    tail = tail->next;
                    l2 = l2->next;
                }
            }
        }
        return head;
    }
